// This file should help with finding what type of build the user is running.
// should take in the directory that you want to explore and 
// run checks to see what type of build it is. Once the build is found,
// we run the neccessary commands to extract out the metadata information.
// In the function descriptions, we sometimes refer to the data structures
// specified in the comment header of the utils file

var path = require('path')
var _ = require('underscore')
var Promise = require('bluebird')
var glob = Promise.promisifyAll(require('glob'))
var fs = Promise.promisifyAll(require('fs'))
var utils = require('./utils.js')

var FILE_GLOB_PATTERN = '*(cpanfile|Makefile\.PL|Build\.PL)'

/**
 * 
 * Find dependencies given the directory to look at and find the dependencies that directory
 * will require. 
 * 
 * @param {string} dir - directory to look into
 * @param {list[string]} ignores - files to ignore
 * @return {package unit object} - object containing the mapping of the main pkg with 
 *                                 it's dependencies:
 * {
 *      id:identifier for the source
 *      version: version of the source
 *      dependencies: {[
 *                        id: identifier for this dependency,
 *                        version: version for this dependency,
 *                        path: file_path || '' 
 *                    ], ...}
 * }      
 */
module.exports = function(dir, ignores) {
    utils.extractMetaFiles(dir)
    .then(function(origMetaInfo){
        var metaFromBuild = getBuildFiles(dir, ignores)
            .map(function (fileFound) {
                return utils.extractMetaFromBuildList(fileFound, dir)
            })
        return origMetaInfo.push(metaFromBuild)
    })
    .then(function (metaInfo){
        // Now that we potentially have multiple source informations
        // we need to figure out what to call our source of truth
        return traigeMetas(metaInfo)
    }).then(function (resolvedDeps){
        return filteredDeps(resolvedDeps)
    })
    
}

/**
 * Given a directory, find all the build files present
 * 
 * @param {string} dir - Directory to look at 
 * @param {[string]} ignores - files we should ignore
 * 
 * @return {[string]} - a string of build files that we saw in the directory
 */
function getBuildFiles(dir, ignores) {
    return glob.globAsync(path.join(dir, FILE_GLOB_PATTERN), { nocase: true })
        .filter(function filterIgnores(file) {
            // filter out the files you want to ignore
            if (!ignores) return true
            file = file.toLowerCase()
            for (var i = 0; i < ignores.length; i++) {
                if (file.indexOf(ignores[i]) >= 0) return false // skip processing file
            }
            return true
    })
}

/**
 * 
 * During the download/build/data extraction, there are multiple files that can provide a source of truth.
 * To not skimp out any information, we collect them all and try to resolve information. 
 * *Important Note* When we gather the meta files, we first get the provided meta.json/yml files first and THEN
 * look at the generated mymeta.json files (generated by the build system). Hence, we will give 
 * precedence to values later in the list.
 * 
 * Also *important* - ever thought you would see recursion again after college?
 * 
 * @param {[source_items,...]} metaInfos 
 * 
 * @return {source_item}
 */
function traigeMetas(metaInfos){
    if (!metaInfos) {
        throw new Error('No metaInfos sent in')
    } else if (metaInfos.length == 1) {
        // base case
        return metaInfos
    } else {
        var first = metaInfos.shift() // Pop the first value in the list
        var second = metaInfos.shift() // Pop the second value in the list
        var resolved = resolveMetaInfo(first, second) // resolve those two
        metaInfos.unshift(resolved) // Reinsert the resolved two back to the front
        return triageMetas(metaInfos) // Recurse
    }
}

/**
 * 
 * Given two source items, resolve the name and version. 
 * Rules:
 * If any ONE is null, take the other
 * If both null, keep null
 * If differing values, give precedence to the second one if there are conflicts.
 * 
 * @param {source_item} first 
 * @param {source_item} second 
 * 
 * @return {source_item}
 * 
 */
function resolveMetaInfo(first, second) {
    var resolvedInfo = {}
    // name
    if (first['name'] && second['name']) {
        resolvedInfo['name'] = second['name']
    } else {
        resolvedInfo['name'] = second['name'] ? second['name'] : first['name']
    }

    // version
    if (first['version'] && second['version']) {
        resolvedInfo['version'] = second['version']
    } else {
        resolvedInfo['version'] = second['version'] ? second['version'] : first['version']
    }

    // dependency list
    resolvedInfo['dependencies'] = resolveDependencyList(first['dependencies'] && second['dependencies'])

    return resolvedInfo
}

/**
 * 
 * Given two dependency lists, resolve the information (name, version, filePath)
 * Rules:
 * If it exists in one list, add it in
 * If exists in both, take the second one
 * 
 * TODO: honestly kind of ugly how I did this
 * 
 * @param {[dependency_item]} firstDeps
 * @param {[dependency_item]} secondDeps
 */
function resolveDependencyList(firstDeps, secondDeps) {
    console.log(firstDeps)
    console.log(secondDeps)
    var firstObj = {}
    var secondObj = {}

    // make them into objects
    firstDeps.forEach(x => firstObj[x['id']] = [x['version'], x['filePath']])
    secondDeps.forEach(x => secondObj[x['id']] = [x['version'], x['filePath']])

    // initial merge
    Object.keys(firstObj).map(function(dep){
        if (dep in secondObj) {
            if (!secondObj[dep][0]) {
                delete secondObj[dep] // just keep the first one
            } else {
                firstObj[dep] = secondObj[dep] // overwrite with the second one
                delete secondObj[dep] // delete the dep from the second one
            }
        }
    })

    Object.assign(firstObj, secondObj)

    // turn back into source_item format
    var toRet = []
    Object.keys(firstObj).map(function toOrigFormat(dep){
        toRet.push({
            'id' : dep,
            'version' : firstObj[dep][0],
            'filePath': firstObj[dep][1],
        })
    })

    return toRet

}

/**
 * 
 * Remove some dependencies that should not be in the dependency list
 * like 'perl', 'ExtUtils::MakeMaker'. These are usually build based modules
 * that are used to configure a project. Not neccesarily used in the proj itself.
 * TODO: In the grand scope of things, this might not be important, but I just included it
 * 
 * @param {source_item} deps
 *
 * @return {source_item}
 */
function filteredDeps(deps) {
    const filteredModules = new Set('perl', 'ExtUtils::MakeMaker', 'CPAN::Meta')
    deps.filter(function(dep){
        if (dep['id'] in filteredModules) {
            return false
        } else {
            return true
        }
    })
}