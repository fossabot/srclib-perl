// This file should help with finding what type of build the user is running.
// should take in the directory that you want to explore and 
// run checks to see what type of build it is. Once the build is found,
// we run the neccessary commands to extract out the metadata information.
// In the function descriptions, we sometimes refer to the data structures
// specified in the comment header of the utils file

var path = require('path')
var _ = require('underscore')
var Promise = require('bluebird')
var glob = Promise.promisifyAll(require('glob'))
var fs = Promise.promisifyAll(require('fs'))
var utils = require('./utils.js')

var FILE_GLOB_PATTERN = '*(cpanfile|Makefile\.PL|Build\.PL)'

/**
 * 
 * Find dependencies given the directory to look at and find the dependencies that directory
 * will require. 
 * 
 * @param {string} dir - directory to look into
 * @param {list[string]} ignores - files to ignore
 * @return {package unit object} - object containing the mapping of the main pkg with 
 *                                 it's dependencies:
 * {
 *      id:identifier for the source
 *      version: version of the source
 *      dependencies: {[
 *                        id: identifier for this dependency,
 *                        version: version for this dependency,
 *                        path: file_path || '' 
 *                    ], ...}
 * }      
 */
module.exports = function(dir, ignores) {
    utils.extractMetaFiles(dir)
    .then(function(origMetaInfo){
        var metaFromBuild = getBuildFiles(dir, ignores)
            .map(function (fileFound) {
                return utils.extractMetaFromBuildList(fileFound, dir)
            })
        return origMetaInfo.push(metaFromBuild)
    })
    .then(function (metaInfo){
        // Now that we potentially have multiple source informations
        // we need to figure out what to call our source of truth
        return traigeMetas(metaInfo)
    })
    
}

/**
 * Given a directory, find all the build files present
 * 
 * @param {string} dir - Directory to look at 
 * @param {[string]} ignores - files we should ignore
 * 
 * @return {[string]} - a string of build files that we saw in the directory
 */
function getBuildFiles(dir, ignores) {
    return glob.globAsync(path.join(dir, FILE_GLOB_PATTERN), { nocase: true })
        .filter(function filterIgnores(file) {
            // filter out the files you want to ignore
            if (!ignores) return true
            file = file.toLowerCase()
            for (var i = 0; i < ignores.length; i++) {
                if (file.indexOf(ignores[i]) >= 0) return false // skip processing file
            }
            return true
    })
}

/**
 * 
 * During the download/build/data extraction, there are multiple files that can provide a source of truth.
 * To not skimp out any information, we collect them all and try to resolve information. 
 * *Important Note* When we gather the meta files, we first get the provided meta.json/yml files first and THEN
 * look at the generated mymeta.json files (generated by the build system). Hence, we will give 
 * precedence to values later in the list.
 * 
 * Also *important* - ever thought you would see recursion again after college?
 * 
 * @param {[source_items,...]} metaInfos 
 * 
 * @return {source_item}
 */
function traigeMetas(metaInfos){
    if (!metaInfos) {
        throw new Error('No metaInfos sent in')
    } else if (metaInfos.length == 1) {
        // base case
        return metaInfos
    } else {
        var first = metaInfos[0]
        var second = metaInfos[1]
        
    }
}

/**
 * 
 * Given two source items, resolve the name and version. 
 * Rules:
 * If any ONE is null, take the other
 * If both null, keep null
 * If differing values, give precedence to the second one if there are conflicts.
 * 
 * @param {source_item} first 
 * @param {source_item} second 
 * 
 * @return {source_item}
 * 
 */
function resolveSourceInfo(first, second)

/**
 * 
 * Given two dependency lists, resolve the information (name, version, filePath)
 * 
 * Todo: this could be a O(N^2) operation. Fix it to be a O(N)
 * 
 * @param {[dependency_item]} firstDep 
 * @param {[dependency_item]} secondDep
 */
function resolveDependencyList(firstDep, secondDep) {
    return secondDep
}